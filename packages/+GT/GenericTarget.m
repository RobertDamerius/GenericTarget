classdef GenericTarget < handle
    properties
        portAppSocket (1,1) uint16 {mustBePositive} = 44000;
        portSSH (1,1) uint16 {mustBePositive} = 22;
        connectTimeout (1,1) uint32 {mustBePositive} = 3;
        targetUsername {mustBeTextScalar, GT.mustBeChar} = '';
        targetIPAddress {mustBeTextScalar, GT.mustBeChar} = '';
        targetSoftwareDirectory {mustBeTextScalar, GT.mustBeChar, GT.mustEndWith(targetSoftwareDirectory,'/')} = '~/GenericTarget/';
        targetProductName {mustBeTextScalar, GT.mustBeChar, mustBeValidVariableName} = 'GenericTarget';
        targetBitmaskCPUCores {mustBeTextScalar, GT.mustBeChar, GT.mustBeHexString} = '';
        applicationArguments {mustBeTextScalar, GT.mustBeChar} = '';
        upperThreadPriority (1,1) uint32 {mustBeInRange(upperThreadPriority, 1, 99)} = 89;
        priorityDataRecorder (1,1) uint32 {mustBeInRange(priorityDataRecorder, 1, 99)} = 30;
        terminateAtTaskOverload (1,1) logical = true;
        terminateAtCPUOverload (1,1) logical = true;
        customCode {mustBeText, GT.mustBeUnique, GT.mustBeCellStr} = cell.empty();
        numberOfOldProtocolFiles (1,1) uint32 = 100;
        additionalCompilerFlags (1,1) GT.CompilerFlags = GT.CompilerFlags();
    end
    methods
        function this = GenericTarget(targetUsername, targetIPAddress)
            %GT.GenericTarget.GenericTarget Create a Generic Target object.
            %
            % PARAMETERS
            % targetUsername  ... The user name of the target PC required to login on target via SSH/SCP.
            % targetIPAddress ... The host name of the target, e.g. IP address.
            arguments
                targetUsername {mustBeTextScalar, GT.mustBeChar} = '';
                targetIPAddress {mustBeTextScalar, GT.mustBeChar} = '';
            end
            this.targetIPAddress = targetIPAddress;
            this.targetUsername = targetUsername;
        end
        function commands = Deploy(this, modelName)
            %GT.GenericTarget.Deploy Deploy the target application. The code for the simulink model will be generated. In addition a simulink
            % interface class will be generated based on the code information from the simulink code generation process. The source code will then be compressed
            % and transferred to the target via SCP. Afterwards an SSH connection will be established to unzip the transferred software and build the target
            % application on the target computer. The application is not started at the end of this process.
            % 
            % PARAMETERS
            % modelName ... The name of the simulink model that should be build (excluding directory and file extension).
            % 
            % RETURN
            % commands ... The commands that were executed on the host.
            arguments
                this
                modelName {mustBeTextScalar, GT.mustBeChar}
            end
            fprintf('[GENERIC TARGET] Starting deployment of model "%s" on target %s at %s\n', modelName, this.targetUsername, this.targetIPAddress);

            % get code directory of simulink and set temporary zip filename
            zipFileName = fullfile(Simulink.fileGenControl('get', 'CodeGenFolder'), [modelName '.zip']);
            if(exist(zipFileName,'file')), delete(zipFileName); end

            % generate code (going to be stored in the zip file)
            this.GenerateCode(zipFileName, modelName);

            % deploy the generated code
            commands = this.DeployGeneratedCode(zipFileName);
        end
        function commands = DeployGeneratedCode(this, zipFileName)
            %GT.GenericTarget.DeployGeneratedCode Deploy generated code to the target hardware. The code for the simulink model must be generated by the GT.GenericTarget.GenerateCode member function.
            % The source code will then be transferred to the target via SCP. Afterwards an SSH connection will be established to unzip the transferred software and build the target
            % application on the target computer. The application is not started at the end of this process.
            % 
            % PARAMETERS
            % zipFileName ... The name of the zip file that contains the code that has been generated using the GT.GenericTarget.GenerateCode member function. The file extension must be '.zip'.
            % 
            % RETURN
            % commands ... The commands that were executed on the host.
            arguments
                this
                zipFileName {mustBeTextScalar, GT.mustBeChar, GT.mustEndWith(zipFileName, '.zip')}
            end
            assert(exist(zipFileName, 'file'), ['GT.GenericTarget.DeployGeneratedCode(): The specified zip file "', zipFileName, '" does not exist!']);
            fprintf('[GENERIC TARGET] Starting code deployment (%s) to target %s at %s\n', zipFileName, this.targetUsername, this.targetIPAddress);
            tStart = tic();

            % SSH: make sure that target software directory exists
            fprintf(['[GENERIC TARGET] SSH: Creating software directory "' this.targetSoftwareDirectory '" on target ' this.targetIPAddress '\n']);
            cmdSSH1 = this.RunCommandOnTarget(['mkdir -p ' this.targetSoftwareDirectory]);

            % SCP: copy zip to target
            targetZipFile = [this.targetSoftwareDirectory 'tmp.zip'];
            cmdSCP = ['scp -o ConnectTimeout=' num2str(this.connectTimeout) ' -P ' num2str(this.portSSH) ' ' zipFileName ' ' this.targetUsername '@' this.targetIPAddress ':' targetZipFile];
            fprintf(['[GENERIC TARGET] SCP: Copy new software to target ' this.targetIPAddress '\n']);
            this.RunCommand(cmdSCP);

            % SSH: remove old code/build/Makfile/etc., unzip new source and compile
            fprintf(['[GENERIC TARGET] SSH: Build new software on target ' this.targetIPAddress '\n']);
            cmdSSH2 = this.RunCommandOnTarget(['sudo rm -r -f ' this.targetSoftwareDirectory '.vscode ' this.targetSoftwareDirectory 'code ' this.targetSoftwareDirectory 'build ' this.targetSoftwareDirectory 'Makefile ' this.targetSoftwareDirectory 'README.md ; unzip -qq -o ' targetZipFile ' -d ' this.targetSoftwareDirectory ' ; sudo rm ' targetZipFile ' ; cd ' this.targetSoftwareDirectory ' && make clean && make -j8']);
            t = toc(tStart);
            fprintf('\n[GENERIC TARGET] Code deployment completed after %f seconds\n', t);
            commands = [cmdSSH1(:); {cmdSCP}; cmdSSH2(:)];
        end
        function DeployToHost(this, modelName, directory)
            %GT.GenericTarget.DeployToHost Deploy the target application to a directory on the host machine. The whole Generic Target framework including the generated
            % code is going to be replaced in the specified directory. The software is not compiled after this deployment.
            % 
            % PARAMETERS
            % modelName ... The name of the simulink model that should be build (excluding directory and file extension).
            % directory ... Optional name of the directory (consider using absolute path) where to save the generated target application code. If no directory is
            %               specified, then the current working directory (pwd) is used.
            arguments
                this
                modelName {mustBeTextScalar, GT.mustBeChar}
                directory {mustBeTextScalar, GT.mustBeChar} = pwd
            end
            tStart = tic();
            fprintf('[GENERIC TARGET] Starting deployment of model "%s" to host (%s)\n', modelName, directory);

            % generate code (going to be stored in a temporary zip file)
            codeGenFolder = Simulink.fileGenControl('get', 'CodeGenFolder');
            zipFileName = fullfile(codeGenFolder, [modelName '.zip']);
            this.GenerateCode(zipFileName, modelName);

            % remove old files and folders that are going to be replaced
            if(exist(directory, 'dir'))
                [~,~] = rmdir(fullfile(directory, '.vscode'), 's');
                [~,~] = rmdir(fullfile(directory, 'build'), 's');
                [~,~] = rmdir(fullfile(directory, 'code'), 's');
                fileReadme = fullfile(directory, 'README.md');
                fileMakefile = fullfile(directory, 'Makefile');
                if(exist(fileReadme, 'file')), delete(fileReadme); end
                if(exist(fileMakefile, 'file')), delete(fileMakefile); end
            end

            % unzip generated code into output directory
            fprintf('[GENERIC TARGET] Unzipping generated model code into "%s"\n', directory);
            unzip(zipFileName, directory);
            t = toc(tStart);
            fprintf('[GENERIC TARGET] Deployment to host completed after %f seconds\n', t);
            fprintf('To compile, open terminal in "%s" and run:\n    make clean && make -j8\n', directory);
        end
        function GenerateCode(this, zipFileName, modelName)
            %GT.GenericTarget.GenerateCode Generate the code for the simulink model and the interface class. The generated code of the interface class
            % is based on the code information from the simulink code generation process. The source code will then be compressed to a .zip file.
            % 
            % PARAMETERS
            % zipFileName ... The name of the zip file where to store the generated code. The file extension must be '.zip'.
            % modelName   ... The name of the simulink model that should be build (excluding directory and file extension). This parameter is forwarded to the slbuild() command.
            arguments
                this
                zipFileName {mustBeTextScalar, GT.mustBeChar, GT.mustEndWith(zipFileName, '.zip')}
                modelName {mustBeTextScalar, GT.mustBeChar}
            end
            tStart = tic();

            % make a fresh release folder that is going to contain the whole software
            fprintf('[GENERIC TARGET] Starting code generation for model "%s"\n', modelName);
            codeGenFolder = Simulink.fileGenControl('get', 'CodeGenFolder');
            releaseFolder = fullfile(codeGenFolder, ['GenericTarget_' modelName]);
            fprintf('[GENERIC TARGET] Creating release folder "%s"\n', releaseFolder);
            [~,~] = rmdir(releaseFolder, 's');
            assert(mkdir(releaseFolder), 'Could not make release folder!');

            % generate release code
            this.CopyFrameworkToReleaseFolder(releaseFolder);
            modelCodeFolder = this.BuildModelToReleaseFolder(modelName, codeGenFolder, releaseFolder);
            this.UpdateGeneratedCode(modelCodeFolder);
            this.BuildInterfaceClass(modelName, codeGenFolder, modelCodeFolder);
            if(numel(this.customCode))
                customCodeFolder = fullfile(releaseFolder, 'code', 'CustomCode');
                fprintf('[GENERIC TARGET] Adding custom code to "%s"\n', customCodeFolder);
                assert(mkdir(customCodeFolder), 'Could not make custom code folder!');
                for i = 1:numel(this.customCode)
                    [~, name, ext] = fileparts(this.customCode{i});
                    [~,~] = copyfile(this.customCode{i}, fullfile(customCodeFolder, [name ext]), 'f');
                end
            end

            % compress code into a zip file
            this.CompressReleaseFolder(releaseFolder, zipFileName);
            t = toc(tStart);
            fprintf('[GENERIC TARGET] Code generation completed after %f seconds\n', t);
        end
        function commands = Start(this)
            %GT.GenericTarget.Start Start the target application. An SSH connection will be established to start the application.
            % If the application is already started, nothing happens.
            % 
            % RETURN
            % commands ... The commands that were executed on the host.
            args = '';
            if(~isempty(this.applicationArguments))
                args = [' ', this.applicationArguments];
            end
            fprintf('[GENERIC TARGET] Starting target software on %s at %s\n', this.targetUsername, this.targetIPAddress);
            commands = this.RunCommandOnTarget(['sudo nohup ' this.GetTasksetOption() this.targetSoftwareDirectory this.targetProductName args ' &> ' this.targetSoftwareDirectory 'out.txt &']);
        end
        function commands = Stop(this)
            %GT.GenericTarget.Stop Stop the target application. An SSH connection will be established to stop the application.
            % If no application is running, nothing happens.
            % 
            % RETURN
            % commands ... The commands that were executed on the host.
            fprintf('[GENERIC TARGET] Stopping target software on %s at %s\n', this.targetUsername, this.targetIPAddress);
            commands = this.RunCommandOnTarget(['sudo ' this.targetSoftwareDirectory this.targetProductName ' --console --stop']);
        end
        function commands = Reboot(this)
            %GT.GenericTarget.Reboot Reboot the target computer. An SSH connection will be established to run a reboot command.
            % 
            % RETURN
            % commands ... The commands that were executed on the host.
            fprintf('[GENERIC TARGET] Rebooting target %s at %s\n', this.targetUsername, this.targetIPAddress);
            commands = this.RunCommandOnTarget('sudo reboot');
        end
        function commands = Shutdown(this)
            %GT.GenericTarget.Shutdown Shutdown the target computer. An SSH connection will be established to run a shutdown command.
            % 
            % RETURN
            % commands ... The commands that were executed on the host.
            fprintf('[GENERIC TARGET] Shutting down target %s at %s\n', this.targetUsername, this.targetIPAddress);
            commands = this.RunCommandOnTarget('sudo shutdown -h now');
        end
        function commands = ShowPID(this)
            %GT.GenericTarget.ShowPID Show the process ID for all processes on the target that are named according to targetProductName.
            % This can be used to check whether the application is running or not. If no process is running the printed console output
            % is empty.
            % 
            % RETURN
            % commands ... The commands that were executed on the host.
            commands = this.RunCommandOnTarget(['pidof ' this.targetProductName]);
        end
        function commands = ShowIsolatedCPUCores(this)
            %GT.GenericTarget.ShowIsolatedCPUs Show the isolated CPUs for the target. If no CPU cores are isolated the printed console output
            % is empty.
            % 
            % RETURN
            % commands ... The commands that were executed on the host.
            commands = this.RunCommandOnTarget('cat /sys/devices/system/cpu/isolated');
        end
        function commands = ShowLatestProtocol(this)
            %GT.GenericTarget.ShowLatestProtocol Show the latest protocol file from the target.
            % 
            % RETURN
            % commands ... The commands that were executed on the host.
            targetProtocolDirectory = this.GetTargetProtocolDirectoryName();
            [cmd1, cmdout] = this.RunCommandOnTarget(['ls -rt ', targetProtocolDirectory, '*.txt | tail -n1']);
            protocolFileOnTarget = strtrim(cmdout);
            [~,f,e] = fileparts(protocolFileOnTarget);
            if(strcmp(f, '*') || ~strcmp(e, '.txt'))
                fprintf('ERROR: Could not find a protocol file on the target!\n');
                commands = cmd1;
                return;
            end
            cmd2 = this.RunCommandOnTarget(['cat ' protocolFileOnTarget]);
            commands = [cmd1(:); cmd2(:)];
        end
        function commands = DownloadAllProtocols(this, hostDirectory)
            %GT.GenericTarget.DownloadAllProtocols Download all protocol files from the target. The downloaded text will be written to the specified hostDirectory.
            % 
            % PARAMETERS
            % hostDirectory ... The destination directory (absolute path) on the host where to write the downloaded files to.
            %                   If the directory does not exist, then it will be created. If this argument is not given, then
            %                   the current working directory is used as default directory.
            % 
            % RETURN
            % commands ... The commands that were executed on the host.
            arguments
                this
                hostDirectory {mustBeTextScalar, GT.mustBeChar} = pwd
            end
            targetProtocolDirectory = this.GetTargetProtocolDirectoryName();
            fprintf('[GENERIC TARGET] Downloading all protocols (%s) from target %s at %s to host (%s)\n', targetProtocolDirectory, this.targetUsername, this.targetIPAddress, hostDirectory);
            [~,~] = mkdir(hostDirectory);
            cmdSCP = ['scp -o ConnectTimeout=' num2str(this.connectTimeout) ' -P ' num2str(this.portSSH) ' -r ' this.targetUsername '@' this.targetIPAddress ':' targetProtocolDirectory ' ' hostDirectory];
            this.RunCommand(cmdSCP);
            commands = {cmdSCP};
            fprintf('[GENERIC TARGET] Download completed\n');
        end
        function commands = DeleteAllProtocols(this)
            %GT.GenericTarget.DeleteAllProtocols Delete all protocol text files on the target. This will also stop a running target application.
            % 
            % RETURN
            % commands ... The commands that were executed on the host.
            targetProtocolDirectory = this.GetTargetProtocolDirectoryName();
            fprintf('[GENERIC TARGET] Stopping target application and deleting all protocol files (%s) from target %s at %s\n', targetProtocolDirectory, this.targetUsername, this.targetIPAddress);
            commands = this.RunCommandOnTarget(['sudo ' this.targetSoftwareDirectory this.targetProductName ' --console --stop ; sudo rm -r -f ' targetProtocolDirectory]);
        end
        function commands = DownloadDataDirectory(this, hostDirectory, targetDataDirectory)
            %GT.GenericTarget.DownloadDataDirectory Download recorded data from the target. The downloaded data will be written to the specified hostDirectory.
            % 
            % PARAMETERS
            % hostDirectory       ... The destination directory (absolute path) on the host where to write the downloaded data to.
            %                         If the directory does not exist, then it will be created. If this argument is not given, then
            %                         the current working directory is used as default directory.
            % targetDataDirectory ... Optional string indicating the data directory name on the target to be downloaded, e.g. "20210319_123456789".
            %                         If this parameter is not given, all data directories existing on the target will be displayed and the user has to
            %                         specify the name manually.
            % 
            % RETURN
            % commands ... The commands that were executed on the host.
            arguments
                this
                hostDirectory {mustBeTextScalar, GT.mustBeChar} = pwd
                targetDataDirectory {mustBeTextScalar, GT.mustBeChar} = '';
            end

            if(filesep ~= hostDirectory(end))
                hostDirectory = [hostDirectory filesep];
            end
            dataFolder = this.GetTargetDataDirectoryName();

            % check if user specified data directory
            cmdSSH = cell.empty();
            if(isempty(targetDataDirectory))
                fprintf('[GENERIC TARGET] Listing available data directories on target %s at %s\n', this.targetUsername, this.targetIPAddress);
                cmdSSH = this.RunCommandOnTarget(['cd ' dataFolder ' && ls']);
                targetDataDirectory = input('[GENERIC TARGET] Choose directory name to download: ', 's');
            end

            % download directory via SCP
            fprintf('[GENERIC TARGET] Downloading %s from target %s at %s\n', targetDataDirectory, this.targetUsername, this.targetIPAddress);
            [~,~] = mkdir(hostDirectory);
            cmdSCP = ['scp -o ConnectTimeout=' num2str(this.connectTimeout) ' -P ' num2str(this.portSSH) ' -r ' this.targetUsername '@' this.targetIPAddress ':' dataFolder targetDataDirectory ' ' hostDirectory targetDataDirectory];
            this.RunCommand(cmdSCP);
            if(isempty(cmdSSH))
                commands = {cmdSCP};
            else
                commands = [cmdSSH; {cmdSCP}];
            end
            fprintf('[GENERIC TARGET] Download completed\n');
        end
        function commands = DownloadAllData(this, hostDirectory)
            %GT.GenericTarget.DownloadAllData Download all recorded data directories from the target. The downloaded data will be written to the specified hostDirectory.
            % 
            % PARAMETERS
            % hostDirectory ... The destination directory (absolute path) on the host where to write the downloaded data to.
            %                   If the directory does not exist, then it will be created. If this argument is not given, then
            %                   the current working directory is used as default directory.
            % 
            % RETURN
            % commands ... The commands that were executed on the host.
            arguments
                this
                hostDirectory {mustBeTextScalar, GT.mustBeChar} = pwd
            end

            if(filesep ~= hostDirectory(end))
                hostDirectory = [hostDirectory filesep];
            end
            dataFolder = this.GetTargetDataDirectoryName();

            % download all data directories via SCP
            fprintf('[GENERIC TARGET] Downloading all data (%s) from target %s at %s to host (%s)\n', dataFolder, this.targetUsername, this.targetIPAddress, hostDirectory);
            [~,~] = mkdir(hostDirectory);
            cmdSCP = ['scp -o ConnectTimeout=' num2str(this.connectTimeout) ' -P ' num2str(this.portSSH) ' -r ' this.targetUsername '@' this.targetIPAddress ':' dataFolder '* ' hostDirectory];
            this.RunCommand(cmdSCP);
            commands = {cmdSCP};
            fprintf('[GENERIC TARGET] Download completed\n');
        end
        function commands = DeleteAllData(this)
            %GT.GenericTarget.DeleteData Delete all recorded data on the target. This will also stop a running target application.
            % 
            % RETURN
            % commands ... The commands that were executed on the host.
            dataFolder = this.GetTargetDataDirectoryName();
            fprintf('[GENERIC TARGET] Stopping target application and deleting all data files (%s) from target %s at %s\n', dataFolder, this.targetUsername, this.targetIPAddress);
            commands = this.RunCommandOnTarget(['sudo ' this.targetSoftwareDirectory this.targetProductName ' --console --stop ; sudo rm -r -f ' dataFolder]);
        end
        function dataDirectory = GetTargetDataDirectoryName(this)
            %GT.GenericTarget.GetTargetDataDirectoryName Get the absolute name of the data directory on the target.
            % 
            % RETURN
            % dataDirectory ... Absolute data directory name on the target (ends with a separator '/').
            dataDirectory = [this.targetSoftwareDirectory, 'data/'];
        end
        function protocolDirectory = GetTargetProtocolDirectoryName(this)
            %GT.GenericTarget.GetTargetProtocolDirectoryName Get the absolute name of the protocol directory on the target.
            % 
            % RETURN
            % protocolDirectory ... Absolute protocol directory name on the target (ends with a separator '/').
            protocolDirectory = [this.targetSoftwareDirectory, 'protocol/'];
        end
        function [commands, cmdout] = RunCommandOnTarget(this, cmd)
            %GT.GenericTarget.RunCommandOnTarget Run a command to the target computer. The command is executed via SSH.
            % 
            % PARAMETERS
            % cmd  ... The command string to be executed on the target computer, e.g. 'ls'.
            % 
            % RETURN
            % commands ... The commands that were executed on the host.
            % cmdout   ... The output that have been returned by the command window.
            arguments
                this
                cmd {mustBeTextScalar, GT.mustBeChar}
            end
            cmdSSH = ['ssh -o ConnectTimeout=' num2str(this.connectTimeout) ' -p ' num2str(this.portSSH) ' ' this.targetUsername '@' this.targetIPAddress ' "' cmd '"'];
            cmdout = this.RunCommand(cmdSSH);
            commands = {cmdSSH};
        end
    end
    methods(Access=private)
        function directory = GetCoreDirectory(~)
            directory = fullfile(extractBefore(mfilename('fullpath'), strlength(mfilename('fullpath')) - strlength(mfilename) + 1), '..', '..', 'core');
        end
        function tasksetOption = GetTasksetOption(this)
            tasksetOption = '';
            if(~isempty(this.targetBitmaskCPUCores))
                tasksetOption = ['taskset ' this.targetBitmaskCPUCores ' '];
            end
        end
        function CopyFrameworkToReleaseFolder(this, releaseFolder)
            % copy folders
            coreDirectory = this.GetCoreDirectory();
            fprintf('[GENERIC TARGET] Copying framework from "%s" to release folder "%s"\n', coreDirectory, releaseFolder);
            srcDirectoryCode = fullfile(coreDirectory, 'code');
            srcFileVSCode = fullfile(coreDirectory, '.vscode');
            assert(exist(srcDirectoryCode, 'dir'), ['Missing files in Generic Target toolbox: ', srcDirectoryCode]);
            assert(exist(srcFileVSCode, 'file'), ['Missing file in Generic Target toolbox: ', srcDirectoryCode]);
            assert(copyfile(srcDirectoryCode, fullfile(releaseFolder, 'code'), 'f'), 'Could not copy Generic Target core files!');
            assert(copyfile(srcFileVSCode, fullfile(releaseFolder, '.vscode'), 'f'), 'Could not copy Generic Target core files!');

            % generate files
            this.GenerateMakefile(releaseFolder);
            this.GenerateReadme(releaseFolder);
            this.OverwriteVSLaunchFile(releaseFolder);
        end
        function GenerateMakefile(this, releaseFolder)
            % read the template Makefile
            srcMakefile = fullfile(this.GetCoreDirectory(), 'Makefile');
            dstMakefile = fullfile(releaseFolder, 'Makefile');
            fprintf('[GENERIC TARGET] Generating Makefile "%s"\n', dstMakefile);
            strMakefile = fileread(srcMakefile);

            % update patterns
            strDEBUG = '0';
            if(this.additionalCompilerFlags.DEBUG_MODE)
                strDEBUG = '1';
            end
            strMakefile = strrep(strMakefile, '$TARGET_MAKEFILE_PRODUCT_NAME$', this.targetProductName);
            strMakefile = strrep(strMakefile, '$TARGET_MAKEFILE_DEBUG_MODE$', strDEBUG);
            strMakefile = strrep(strMakefile, '$TARGET_MAKEFILE_LIBS_WIN$', strjoin(this.additionalCompilerFlags.LIBS_WIN));
            strMakefile = strrep(strMakefile, '$TARGET_MAKEFILE_LIBS_UNIX$', strjoin(this.additionalCompilerFlags.LIBS_UNIX));
            strMakefile = strrep(strMakefile, '$TARGET_MAKEFILE_CC_SYMBOLS$', strjoin(this.additionalCompilerFlags.CC_SYMBOLS));
            strMakefile = strrep(strMakefile, '$TARGET_MAKEFILE_CC_FLAGS$', strjoin(this.additionalCompilerFlags.CC_FLAGS));
            strMakefile = strrep(strMakefile, '$TARGET_MAKEFILE_CPP_FLAGS$', strjoin(this.additionalCompilerFlags.CPP_FLAGS));
            strMakefile = strrep(strMakefile, '$TARGET_MAKEFILE_LD_FLAGS$', strjoin(this.additionalCompilerFlags.LD_FLAGS));
            strMakefile = strrep(strMakefile, '$TARGET_MAKEFILE_INCLUDE_PATHS$', strjoin(this.additionalCompilerFlags.INCLUDE_PATHS));
            strMakefile = strrep(strMakefile, '$TARGET_MAKEFILE_LIBRARY_PATHS$', strjoin(this.additionalCompilerFlags.LIBRARY_PATHS));

            % write Makefile to release folder
            fidMakefile = fopen(dstMakefile, 'w');
            if(-1 == fidMakefile)
                error('Could not write to file "%s"', dstMakefile);
            end
            fwrite(fidMakefile, uint8(strMakefile));
            fclose(fidMakefile);
        end
        function GenerateReadme(this, releaseFolder)
            % read the template readme file
            srcReadme = fullfile(this.GetCoreDirectory(), 'README.md');
            dstReadme = fullfile(releaseFolder, 'README.md');
            fprintf('[GENERIC TARGET] Generating readme file "%s"\n', dstReadme);
            strReadme = fileread(srcReadme);

            % update pattern
            strReadme = strrep(strReadme, '$TARGET_README_PRODUCT_NAME$', this.targetProductName);

            % write readme file to release folder
            fidReadme = fopen(dstReadme, 'w');
            if(-1 == fidReadme)
                error('Could not write to file "%s"', dstReadme);
            end
            fwrite(fidReadme, uint8(strReadme));
            fclose(fidReadme);
        end
        function OverwriteVSLaunchFile(this, releaseFolder)
            % read the launch file
            srcLaunch = fullfile(this.GetCoreDirectory(), '.vscode', 'launch.json');
            dstLaunch = fullfile(releaseFolder, '.vscode', 'launch.json');
            strLaunch = fileread(srcLaunch);

            % update pattern
            strLaunch = strrep(strLaunch, '$TARGET_LAUNCH_PRODUCT_NAME$', this.targetProductName);

            % overwrite launch file to release folder
            fidLaunch = fopen(dstLaunch, 'w');
            if(-1 == fidLaunch)
                error('Could not write to file "%s"', dstLaunch);
            end
            fwrite(fidLaunch, uint8(strLaunch));
            fclose(fidLaunch);
        end
        function modelCodeFolder = BuildModelToReleaseFolder(~, modelName, codeGenFolder, releaseFolder)
            % run code generation (model must be configured to pack the generated code into the PackNGo archive)
            fprintf('[GENERIC TARGET] Building model code ...\n');
            slbuild(modelName);
            zipFileGeneratedCode = fullfile(codeGenFolder, 'PackNGo.zip');
            assert(exist(zipFileGeneratedCode, 'file'), ['Code generation of model "' modelName '" did not produce a PackNGo.zip! Make sure to use the template simulink model. You can get the template model by calling GT.GetTemplate().']);

            % unpack the generated code to the release folder
            modelCodeFolder = fullfile(releaseFolder, 'code', 'SimulinkCodeGeneration');
            fprintf('[GENERIC TARGET] Unpacking generated model code "%s" to "%s"\n', zipFileGeneratedCode, modelCodeFolder);
            unzip(zipFileGeneratedCode, modelCodeFolder);
            delete(zipFileGeneratedCode);

            % delete all non-source files that have been generated during simulink code generation
            listings = dir(fullfile(modelCodeFolder, ['**', filesep, '*.*']));
            listings = listings(~[listings.isdir]);
            for i = 1:numel(listings)
                if(~endsWith(listings(i).name, {'.c', '.cc', '.cpp', '.cxx', '.h', '.hh', '.hpp', '.hxx', '.asm', '.s', '.ipp', '.tcc'}, 'IgnoreCase', true))
                    delete(fullfile(listings(i).folder, listings(i).name));
                end
            end
        end
        function UpdateGeneratedCode(this, directory)
            fprintf('[GENERIC TARGET] Updating generated code directory %s\n', directory);

            % get list of all files in directory and check file by file
            listings = dir(fullfile(directory, ['**', filesep, '*.*']));
            listings = listings(~[listings.isdir]);
            for i = 1:numel(listings)
                currentFile = fullfile(listings(i).folder, listings(i).name);

                % check for rtw_windows.h or rtw_linux.h: replace those
                if(strcmp('rtw_windows.h', listings(i).name) || strcmp('rtw_linux.h', listings(i).name))
                    templateFile = fullfile(this.GetCoreDirectory(), ['gt_template_', listings(i).name]);
                    fprintf('    Replacing file "%s"\n', currentFile);
                    delete(currentFile);
                    [~,~] = copyfile(templateFile, currentFile, 'f');
                    continue;
                end

                % check for rtw_windows.c or rtw_linux.c: delete those
                if(strcmp('rtw_windows.c', listings(i).name) || strcmp('rtw_linux.c', listings(i).name))
                    fprintf('    Deleting file "%s"\n', currentFile);
                    delete(currentFile);
                    continue;
                end

                % delete file if it contains the string "int_T main(" and "int main(" in a line
                deleteFile = false;
                fid = fopen(currentFile);
                while(~feof(fid))
                    line = fgetl(fid);
                    if(~ischar(line)), continue; end
                    deleteFile = contains(line, 'int_T main(');
                    if(deleteFile), break; end
                    deleteFile = contains(line, 'int main(');
                    if(deleteFile), break; end
                end
                fclose(fid);
                if(deleteFile)
                    fprintf('    Deleting file "%s"\n', currentFile);
                    delete(currentFile);
                end
            end
        end
        function BuildInterfaceClass(this, modelName, codeGenFolder, modelCodeFolder)
            % load code information
            codeInfoFile = fullfile(codeGenFolder, [modelName '_grt_rtw'], 'codeInfo.mat');
            fprintf('[GENERIC TARGET] Loading code information "%s"\n', codeInfoFile);
            S = load(codeInfoFile, 'codeInfo');
            codeInfo = S.codeInfo;

            % generate interface code from code information and write to header file (.hpp) and source file (.cpp) to code generation directory
            fprintf('[GENERIC TARGET] Generating interface code\n');
            [strInterfaceHeader, strInterfaceSource] = this.GenerateInterfaceCode(modelName, codeInfo);
            headerFile = fullfile(modelCodeFolder, 'SimulinkInterface.hpp');
            sourceFile = fullfile(modelCodeFolder, 'SimulinkInterface.cpp');
            fidHeader = fopen(headerFile, 'w');
            fidSource = fopen(sourceFile, 'w');
            if(-1 == fidHeader)
                error('Could not write to file "%s"', headerFile);
            end
            if(-1 == fidSource)
                error('Could not write to file "%s"', sourceFile);
            end
            fwrite(fidHeader, uint8(strInterfaceHeader));
            fwrite(fidSource, uint8(strInterfaceSource));
            fclose(fidHeader);
            fclose(fidSource);
        end
        function [strHeader, strSource] = GenerateInterfaceCode(this, modelName, codeInfo)
            % get the model name, both for function names and information
            strNameOfModel = char.empty();
            for i = 1:numel(modelName)
                if((uint8(modelName(i)) >= uint8(20)) && (uint8(modelName(i)) <= uint8(126)))
                    strNameOfModel = append(strNameOfModel, modelName(i));
                end
            end

            % get name of class and corresponding header file name
            strNameOfClass = codeInfo.ConstructorFunction.Prototype.Name;
            strNameOfClassHeader = codeInfo.ConstructorFunction.Prototype.HeaderFile;

            % get initialize and terminate function prototypes
            assert(isempty(codeInfo.UpdateFunctions), 'GT.GenericTarget.GenerateInterfaceCode(): Code generation information contains update functions! However, no update functions are supported!');
            assert(isscalar(codeInfo.InitializeFunctions), 'GT.GenericTarget.GenerateInterfaceCode(): Code generation information contains several initialization functions! However, only one initialization function is supported!');
            assert(isscalar(codeInfo.TerminateFunctions), 'GT.GenericTarget.GenerateInterfaceCode(): Code generation information contains several termination functions! However, only one termination function is supported!');
            strModelInitialize = codeInfo.InitializeFunctions.Prototype.Name;
            strModelTerminate = codeInfo.TerminateFunctions.Prototype.Name;

            % number of output functions (different sample rates)
            numTimings = uint32(numel(codeInfo.OutputFunctions));
            strNumTimings = sprintf('%d',numTimings);
            assert(numTimings > 0, 'GT.GenericTarget.GenerateInterfaceCode(): There must be at least one model step function!');

            % get the lowest sampletime (this is the base sample time)
            baseSampleTime = inf;
            for n = uint32(1):numTimings
                assert(strcmp(codeInfo.OutputFunctions(n).Timing.TimingMode,'PERIODIC'), 'GT.GenericTarget.GenerateInterfaceCode(): Timing mode for all model step functions must be "PERIODIC"!');
                assert(strcmp(codeInfo.OutputFunctions(n).Timing.TaskingMode, 'IMPLICIT_TASKING') || strcmp(codeInfo.OutputFunctions(n).Timing.TaskingMode, 'EXPLICIT_TASKING'), 'GT.GenericTarget.GenerateInterfaceCode(): Tasking mode for all model step functions must be either "IMPLICIT_TASKING" or "EXPLICIT_TASKING"!');
                assert(codeInfo.OutputFunctions(n).Timing.SamplePeriod > 0, 'GT.GenericTarget.GenerateInterfaceCode(): The SamplePeriod must be greater than zero!');
                assert(codeInfo.OutputFunctions(n).Timing.SampleOffset >= 0, 'GT.GenericTarget.GenerateInterfaceCode(): A negative SampleOffset is not supported for output functions!');
                if(codeInfo.OutputFunctions(n).Timing.SamplePeriod < baseSampleTime)
                    baseSampleTime = codeInfo.OutputFunctions(n).Timing.SamplePeriod;
                end
            end
            strBaseSampleTime = sprintf('%.16f',baseSampleTime);

            % get priority array, sampleTick array, prototype names and task names
            priorities = uint32(zeros(numTimings, 1));
            sampleTicks = uint32(zeros(numTimings, 1));
            offsetTicks = int32(zeros(numTimings, 1));
            stepPrototypes = string(zeros(numTimings, 1));
            taskNames = string(zeros(numTimings, 1));
            for n = uint32(1):numTimings
                priorities(n) = codeInfo.OutputFunctions(n).Timing.Priority;
                sampleTicks(n) = uint32(round(codeInfo.OutputFunctions(n).Timing.SamplePeriod / baseSampleTime));
                offsetTicks(n) = int32(round(codeInfo.OutputFunctions(n).Timing.SampleOffset / baseSampleTime));
                stepPrototypes(n) = codeInfo.OutputFunctions(n).Prototype.Name;
                taskNames(n) = codeInfo.OutputFunctions(n).Timing.NonFcnCallPartitionName;
            end

            % check for unique task names
            assert(numel(unique(taskNames)) == numel(taskNames), 'GT.GenericTarget.GenerateInterfaceCode(): Task and/or partition names are not unique!');

            % set priority based on upper thread priority
            maxPriority = uint32(max(priorities));
            priorities = priorities + max(this.upperThreadPriority, maxPriority) - maxPriority;

            % generate strings
            strArraySampleTicks = sprintf('%d', sampleTicks(1));
            strArrayOffsetTicks = sprintf('%d', offsetTicks(1));
            strArrayPriorities = sprintf('%d', priorities(1));
            strArrayTaskNames = sprintf('"%s"', taskNames(1));
            strStepSwitch = sprintf('        case 0: model.%s(); break;', stepPrototypes(1));
            for n = uint32(2):numTimings
                strArraySampleTicks = strcat(strArraySampleTicks, sprintf(',%d', sampleTicks(n)));
                strArrayOffsetTicks = strcat(strArrayOffsetTicks, sprintf(',%d', offsetTicks(n)));
                strArrayPriorities = strcat(strArrayPriorities, sprintf(',%d', priorities(n)));
                strStepSwitch = append(strStepSwitch, sprintf('\n        case %d: model.%s(); break;', uint32(n-1), stepPrototypes(n)));
                strArrayTaskNames = append(strArrayTaskNames, sprintf(', "%s"', taskNames(n)));
            end

            % get priority for data recording thread
            strpriorityDataRecorder = sprintf('%d', this.priorityDataRecorder);

            % get port for application socket
            strPortAppSocket = sprintf('%d', this.portAppSocket);

            % get task overload behaviour
            strTerminateAtTaskOverload = 'false';
            if(this.terminateAtTaskOverload)
                strTerminateAtTaskOverload = 'true';
            end

            % get CPU overload behaviour
            strTerminateAtCPUOverload = 'false';
            if(this.terminateAtCPUOverload)
                strTerminateAtCPUOverload = 'true';
            end

            % get number of old protocol files to keep
            strNumberOfOldProtocolFiles = sprintf('%d', this.numberOfOldProtocolFiles);

            % read template interface files and replace macros in both header and source template code
            strHeader = fileread(fullfile(this.GetCoreDirectory(), 'gt_template_simulink_interface.hpp'));
            strSource = fileread(fullfile(this.GetCoreDirectory(), 'gt_template_simulink_interface.cpp'));
            strHeader = strrep(strHeader, '$NAME_OF_MODEL$', strNameOfModel);
            strSource = strrep(strSource, '$NAME_OF_MODEL$', strNameOfModel);
            strHeader = strrep(strHeader, '$NAME_OF_CLASS$', strNameOfClass);
            strSource = strrep(strSource, '$NAME_OF_CLASS$', strNameOfClass);
            strHeader = strrep(strHeader, '$NAME_OF_CLASSHEADER$', strNameOfClassHeader);
            strSource = strrep(strSource, '$NAME_OF_CLASSHEADER$', strNameOfClassHeader);
            strHeader = strrep(strHeader, '$CODE_INFO_INITIALIZE$', strModelInitialize);
            strSource = strrep(strSource, '$CODE_INFO_INITIALIZE$', strModelInitialize);
            strHeader = strrep(strHeader, '$CODE_INFO_TERMINATE$', strModelTerminate);
            strSource = strrep(strSource, '$CODE_INFO_TERMINATE$', strModelTerminate);
            strHeader = strrep(strHeader, '$NUM_TIMINGS$', strNumTimings);
            strSource = strrep(strSource, '$NUM_TIMINGS$', strNumTimings);
            strHeader = strrep(strHeader, '$BASE_SAMPLE_TIME$', strBaseSampleTime);
            strSource = strrep(strSource, '$BASE_SAMPLE_TIME$', strBaseSampleTime);
            strHeader = strrep(strHeader, '$ARRAY_SAMPLE_TICKS$', strArraySampleTicks);
            strSource = strrep(strSource, '$ARRAY_SAMPLE_TICKS$', strArraySampleTicks);
            strHeader = strrep(strHeader, '$ARRAY_OFFSET_TICKS$', strArrayOffsetTicks);
            strSource = strrep(strSource, '$ARRAY_OFFSET_TICKS$', strArrayOffsetTicks);
            strHeader = strrep(strHeader, '$ARRAY_PRIORITIES$', strArrayPriorities);
            strSource = strrep(strSource, '$ARRAY_PRIORITIES$', strArrayPriorities);
            strHeader = strrep(strHeader, '$ARRAY_TASK_NAMES$', strArrayTaskNames);
            strSource = strrep(strSource, '$ARRAY_TASK_NAMES$', strArrayTaskNames);
            strHeader = strrep(strHeader, '$STEP_SWITCH$', strStepSwitch);
            strSource = strrep(strSource, '$STEP_SWITCH$', strStepSwitch);
            strHeader = strrep(strHeader, '$PRIORITY_DATA_RECORDER$', strpriorityDataRecorder);
            strSource = strrep(strSource, '$PRIORITY_DATA_RECORDER$', strpriorityDataRecorder);
            strHeader = strrep(strHeader, '$PORT_APP_SOCKET$', strPortAppSocket);
            strSource = strrep(strSource, '$PORT_APP_SOCKET$', strPortAppSocket);
            strHeader = strrep(strHeader, '$TERMINATE_AT_TASK_OVERLOAD$', strTerminateAtTaskOverload);
            strSource = strrep(strSource, '$TERMINATE_AT_TASK_OVERLOAD$', strTerminateAtTaskOverload);
            strHeader = strrep(strHeader, '$TERMINATE_AT_CPU_OVERLOAD$', strTerminateAtCPUOverload);
            strSource = strrep(strSource, '$TERMINATE_AT_CPU_OVERLOAD$', strTerminateAtCPUOverload);
            strHeader = strrep(strHeader, '$NUMBER_OF_OLD_PROTOCOL_FILES$', strNumberOfOldProtocolFiles);
            strSource = strrep(strSource, '$NUMBER_OF_OLD_PROTOCOL_FILES$', strNumberOfOldProtocolFiles);
        end
        function CompressReleaseFolder(~, releaseFolder, zipFileName)
            % get all listings from the release folder
            L = dir(releaseFolder);
            L = L(~ismember({L.name}, {'.', '..'}));
            releaseListings = cell.empty();
            for i = 1:numel(L)
                releaseListings(i) = {fullfile(L(i).folder, L(i).name)};
            end

            % compress all listings from the release folder
            fprintf('[GENERIC TARGET] Compressing release code into "%s"\n', zipFileName);
            if(exist(zipFileName, 'file')), delete(zipFileName); end
            zip(zipFileName, releaseListings);
            [~,~] = rmdir(releaseFolder, 's');
        end
        function cmdout = RunCommand(~, cmd)
            [~,cmdout] = system(cmd, '-echo');
        end
    end
end

